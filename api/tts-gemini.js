/**
 * Vercel Serverless Function for Google Gemini TTS
 * This securely handles Gemini API calls server-side
 */

import { GoogleGenAI, Modality } from "@google/genai";

export default async function handler(req, res) {
  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { text, voice = 'Kore' } = req.body;

  if (!text || typeof text !== 'string') {
    return res.status(400).json({ error: 'Text is required' });
  }

  const apiKey = process.env.API_KEY;
  
  if (!apiKey || apiKey === '""' || apiKey === 'undefined' || apiKey.trim() === '') {
    console.error('‚ùå API_KEY (Gemini) not configured');
    return res.status(500).json({ error: 'Gemini API key not configured' });
  }

  console.log('üéôÔ∏è Gemini API request:', { voice, textLength: text.length });

  try {
    const ai = new GoogleGenAI({ apiKey });
    
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash-preview-tts",
      contents: [{ parts: [{ text }] }],
      config: {
        responseModalities: [Modality.AUDIO],
        speechConfig: {
          voiceConfig: {
            prebuiltVoiceConfig: { voiceName: voice },
          },
        },
      },
    });

    if (!response.candidates || response.candidates.length === 0) {
      console.error('‚ùå Gemini: No candidates in response');
      return res.status(500).json({ error: 'No audio generated by Gemini' });
    }

    const candidate = response.candidates[0];
    
    if (candidate.finishReason === 'SAFETY') {
      console.error('‚ùå Gemini: Blocked by safety protocols');
      return res.status(400).json({ error: 'Content blocked by safety filters' });
    }

    let base64Audio;
    for (const part of candidate.content?.parts || []) {
      if (part.inlineData?.data) {
        base64Audio = part.inlineData.data;
        break;
      }
    }

    if (!base64Audio) {
      console.error('‚ùå Gemini: No audio data in response');
      return res.status(500).json({ error: 'No audio data in Gemini response' });
    }

    console.log('‚úÖ Gemini: Audio data received, length:', base64Audio.length);

    // Decode base64 to binary
    const audioBuffer = Buffer.from(base64Audio, 'base64');
    
    if (audioBuffer.length === 0) {
      console.error('‚ùå Empty audio buffer after decoding');
      return res.status(500).json({ error: 'Empty audio data after decoding' });
    }

    // Create WAV header for PCM audio (24kHz, 16-bit, mono)
    const pcmData = new Uint8Array(audioBuffer);
    const wavBuffer = createWavBuffer(pcmData, 24000, 1);

    console.log('‚úÖ WAV buffer created:', wavBuffer.length, 'bytes');

    // Set proper headers for audio streaming
    res.setHeader('Content-Type', 'audio/wav');
    res.setHeader('Content-Length', wavBuffer.length.toString());
    res.setHeader('Cache-Control', 'public, max-age=31536000');
    
    // Send the WAV buffer
    res.send(wavBuffer);
  } catch (error) {
    console.error('‚ùå Gemini TTS error:', error);
    return res.status(500).json({ error: error.message || 'Failed to generate speech' });
  }
}

// Helper function to create WAV file buffer
function createWavBuffer(pcmData, sampleRate, numChannels) {
  const dataLength = pcmData.length;
  const wavBuffer = Buffer.alloc(44 + dataLength);
  
  // RIFF identifier
  wavBuffer.write('RIFF', 0);
  // RIFF chunk size
  wavBuffer.writeUInt32LE(36 + dataLength, 4);
  // WAVE identifier
  wavBuffer.write('WAVE', 8);
  // fmt chunk identifier
  wavBuffer.write('fmt ', 12);
  // fmt chunk size
  wavBuffer.writeUInt32LE(16, 16);
  // audio format (1 for PCM)
  wavBuffer.writeUInt16LE(1, 20);
  // number of channels
  wavBuffer.writeUInt16LE(numChannels, 22);
  // sample rate
  wavBuffer.writeUInt32LE(sampleRate, 24);
  // byte rate
  wavBuffer.writeUInt32LE(sampleRate * numChannels * 2, 28);
  // block align
  wavBuffer.writeUInt16LE(numChannels * 2, 32);
  // bits per sample
  wavBuffer.writeUInt16LE(16, 34);
  // data chunk identifier
  wavBuffer.write('data', 36);
  // data chunk size
  wavBuffer.writeUInt32LE(dataLength, 40);
  // PCM data
  pcmData.copy(wavBuffer, 44);
  
  return wavBuffer;
}
